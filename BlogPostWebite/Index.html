<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>My Experience With Network Booting</title>
    <link href="main.css" rel="stylesheet" type="text/css">
  </head>
  <body>

<h1>
    Network Booting a raspberry Pi
</h1>
<h2>
    Why would anyone want to Network Boot?
</h2>
<p>
    When I say network booting, I mean running a client computer from another
    server computer, where all of the files are stored on the server and there
    is no hard drive on the client. This is useful because it means you can
    manage the computer remotely, you could install new things, restore it,
    update new software all from the server, this is especially helpful when
    you have multiple clients all connected to one server because they can all
    be modified all at once, or perhaps you want multiple devices to all have
    exactly the same data on them.
</p>
<h2>
    But what real world use does that have?
</h2>
<p>
    In this project I’ve used two raspberry Pi’s which are very small computers
    which can basically fit anywhere and can be modified to create any number
    of things, a popular example of this is kiosks which can be managed all
    remotely from a central server and a huge benefit of this is any sensitive
    data is safe because these are entirely volatile computers. Another simple
    real-world use is when you need a computer in a space you simply can’t get
    to all that easily, instead you could just place a Pi in there once and
    from the server computer perform any tasks you need to.
</p>
<h2>
    Setup/ Installation
</h2>
<p>
    If you have a raspberry Pi model 3B+ or newer as your client, you’re
    already setup and ready to use network booting.
</p>
<p>
    For this I’m going to assume you already have an existing home network, so
    all you need to do is connect the Pi to the network using the Ethernet
    port.
</p>
<p>
    To configure the server Pi download and install Raspbian Buster with
    desktop from
    <a href="https://www.raspberrypi.org/downloads/raspbian/">
        https://www.raspberrypi.org/downloads/raspbian/
    </a>
</p>
<p>
    Once you have Raspbian setup it’s recommended that you expand the root file
    system, to do this open terminal and run sudo raspi-config select option 7
    and then select option A1.
</p>
<p>
    Once you’ve done that you can use the script in the repository called
    CreateSetupDirectory.py, this clones the filesystem for Raspbian and places
    it in a new folder called nfs, it also regenerates the ssh keys.
</p>
<p>
    Next you need to setup a DNS and a DHCP server
</p>
<p>
    Run the next script called configureDNSDHCP and follow the on-screen
    instructions.
</p>
<p>
    The next steps for installation haven’t been developed into an automated
    system yet (but that is coming in the next release) so for the remained of
    the setup you will have to type certain commands into the terminal.
</p>
<p>
    Enter ip -4 addr show dev eth0 | grep inet and note down the output, it
    should look like inet 10.42.0.211/24 brd 10.42.0.255 scope global eth0, the
    number after the brd is the broadcast address you’ll need it in a second.
</p>
<p>
    Run these commands
</p>
<code>
    sudo apt install tcpdump dnsmasq
    sudo systemctl enable dnsmasq
    sudo tcpdump -i eth0 port bootpc
</code>
<p>
    At this point you should turn on the client Pi and connect it to the
    network, now wait for it to bootup and on the server you should see a
    packet appear which should look like “DHCP/BOOTP, Request From”, once
    you’ve seen this that means that the Pi is looking for something to boot
    into, now you can stop searching by pressing ctrl+c.
</p>
<code>
    Now enter echo | sudo tee /etc/dnsmasq.conf
    sudo nano /etc/dnsmasq.conf
</code>
<p>
    This will bring up an editor for a text file, replace the content with
    this;
</p>
<p>
    port=0
</p>
    dhcp-range=*********,proxy
</p>
<p>
    log-dhcp
</p>
<p>
    enable-tftp
</p>
<p>
    tftp-root=/tftpboot
</p>
<p>
    pxe-service=0,"Raspberry Pi Boot"
</p>
<p>
    And replace the ******* with the broadcast address from earlier.
</p>
<p>
    Now to need to create a directory to boot from
</p>
<code>
    sudo mkdir /tftpboot

    sudo chmod 777 /tftpboot
    sudo systemctl enable dnsmasq.service

    sudo systemctl restart dnsmasq.service
    cp -r /boot/* /tftpboot
    sudo systemctl restart dnsmasq
</code>
<p>
    At this point your Pi should boot and is now looking for files to boot
    into, to do this we need to export the nfs folder created at the first
    step, enter the following.
</p>
<code>
    sudo apt install nfs-kernel-server
    echo "/nfs/client1 *(rw,sync,no_subtree_check,no_root_squash)" | sudo tee
    -a /etc/exports
    echo "/tftpboot *(rw,sync,no_subtree_check,no_root_squash)" | sudo tee -a
    /etc/exports
    sudo systemctl enable rpcbind
    sudo systemctl restart rpcbind
    sudo systemctl enable nfs-kernel-server
    sudo systemctl restart nfs-kernel-server
</code>
<p>
    Open the text file at /tftpboot/cmdline.txt and look for a line that looks
    like root= and replace it with
</p>
<p>
    root=/dev/nfs nfsroot=*****:/nfs/client1,vers=4.1,proto=tcp rw ip=dhcp
    rootwait elevator=deadline
</p>
<p>
    and replace the ***** with the first half of the number you noted down
    earlier (between the inet and the /24)
</p>
<p>
    Lastly you need to edit /nfs/client1/etc/fstab and make it so that only the
    line that starts ‘proc’ remains (you should have to remove ‘/dev/mmcblk0p1’
    and ‘p2’)
</p>
<p>
    Finally add the boot partition back in
</p>
<code>
    Enter echo "*****:/tftpboot /boot nfs defaults,vers=4.1,proto=tcp 0 0" |
    sudo tee -a /nfs/client1/etc/fstab
</code>
<p>
    Where ***** is the same as the last time you entered an address (between
    inet and /24)
</p>
<p>
    into the terminal and wait for the Pi to boot up.
</p>
<h2>
    Overall
</h2>
<p>
    The point of this tutorial was taking a very complex task which is hard to
    perfect and get working properly every time and create a way that
    simplifies its creation and assists anyone who wants to continue this on
    and create something so that they aren’t struggling on these earlier stages
    like I was before. If you manage to recreate this and get it working I
    encourage you to take it to the next step and create a network booted
    device like the kiosks mentioned above, I would recommend looking at how to
    create python scripts that execute on bootup, that end would be far more
    coding and traditional computer science than the stages laid out in this
    blog post, if you have an interest in networking or want to learn how boot
    processes works or you have a raspberry pi laying around.
</p>
<h2>
    Improvements
</h2>
<p>
    In the future I wish to extend this project further and develop more
    functionality and potentially turn it into a system that automatically runs
    upon bootup, but let me lay out a timeline for work, if you plan on
    continuing on this work you could think of this as a suggested work plan
</p>
<ul>
    <li>
        Finish the automated installation
    </li>
    <li>
        Create a script to automatically setup dnsmasq
    </li>
    <li>
        Create a script to automatically setup the network file system root
    </li>
    <li>
        Modify all of the scripts to work better and more efficiently
    </li>
    <li>
        Modify all of the scripts to run as a single executable
    </li>
    <li>
        Create a monitoring or diagnostics system
    </li>
    <li>
        Create a way that the client raspberry Pi sends information back to the
        server about current runtime conditions, this would be very useful as
        sometimes if you scaled up this solution you would have Pi’s that you
        can’t access or you have to many to monitor them all individually.
    </li>
    <li>
        Start to develop some scripts that automatically compile on bootup
    </li>
    <li>
        As this is a raspberry Pi there is lots of information out there on how
        to transform it into a simple machine that can automatically execute
        scripts and perform actions, similar to an Arduino.
    </li>
    <li>
        Create a full system that is remote booted and has real world use and
        is beneficial to its users
    </li>
    <li>
        Ideally this project will be completed when I have a system where the
        client Pi boots over a network and becomes a machine that I have
        programmed.
    </li>
</ul>
</<body>
</html>
